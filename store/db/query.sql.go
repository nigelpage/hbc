// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package dbstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMember = `-- name: CreateMember :one
INSERT INTO members (membership_number,
                     first_name, 
                     last_name,
                     email,
                     phone,
                     is_bowling_member,
                     is_life_member)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at
`

type CreateMemberParams struct {
	MembershipNumber int32
	FirstName        string
	LastName         string
	Email            pgtype.Text
	Phone            pgtype.Text
	IsBowlingMember  pgtype.Bool
	IsLifeMember     pgtype.Bool
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (Member, error) {
	row := q.db.QueryRow(ctx, createMember,
		arg.MembershipNumber,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.IsBowlingMember,
		arg.IsLifeMember,
	)
	var i Member
	err := row.Scan(
		&i.MembershipNumber,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.IsBowlingMember,
		&i.IsLifeMember,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateMember = `-- name: DeactivateMember :exec
UPDATE members
SET is_active = FALSE
WHERE membership_number = $1
`

func (q *Queries) DeactivateMember(ctx context.Context, membershipNumber int32) error {
	_, err := q.db.Exec(ctx, deactivateMember, membershipNumber)
	return err
}

const findMembersByName = `-- name: FindMembersByName :many
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE (first_name ILIKE '%' || $1 || '%' OR last_name ILIKE '%' || $1 || '%')
AND is_active = TRUE
ORDER BY last_name, first_name
`

func (q *Queries) FindMembersByName(ctx context.Context, dollar_1 pgtype.Text) ([]Member, error) {
	rows, err := q.db.Query(ctx, findMembersByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MembershipNumber,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsBowlingMember,
			&i.IsLifeMember,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBowlingMembers = `-- name: GetBowlingMembers :many
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE is_bowling_member = TRUE AND is_active = TRUE
ORDER BY last_name, first_name
`

func (q *Queries) GetBowlingMembers(ctx context.Context) ([]Member, error) {
	rows, err := q.db.Query(ctx, getBowlingMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MembershipNumber,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsBowlingMember,
			&i.IsLifeMember,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInactiveMembers = `-- name: GetInactiveMembers :many
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE is_active = FALSE
ORDER BY last_name, first_name
`

func (q *Queries) GetInactiveMembers(ctx context.Context) ([]Member, error) {
	rows, err := q.db.Query(ctx, getInactiveMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MembershipNumber,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsBowlingMember,
			&i.IsLifeMember,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLifeMembers = `-- name: GetLifeMembers :many
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE is_life_member = TRUE AND is_active = TRUE
ORDER BY last_name, first_name
`

func (q *Queries) GetLifeMembers(ctx context.Context) ([]Member, error) {
	rows, err := q.db.Query(ctx, getLifeMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MembershipNumber,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsBowlingMember,
			&i.IsLifeMember,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberById = `-- name: GetMemberById :one
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE membership_number = $1 AND is_active = TRUE
`

func (q *Queries) GetMemberById(ctx context.Context, membershipNumber int32) (Member, error) {
	row := q.db.QueryRow(ctx, getMemberById, membershipNumber)
	var i Member
	err := row.Scan(
		&i.MembershipNumber,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.IsBowlingMember,
		&i.IsLifeMember,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMembers = `-- name: GetMembers :many
SELECT membership_number, first_name, last_name, email, phone, is_bowling_member, is_life_member, is_active, created_at, updated_at FROM members
WHERE is_active = TRUE
ORDER BY last_name, first_name
`

func (q *Queries) GetMembers(ctx context.Context) ([]Member, error) {
	rows, err := q.db.Query(ctx, getMembers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Member
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.MembershipNumber,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.IsBowlingMember,
			&i.IsLifeMember,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reactivateMember = `-- name: ReactivateMember :exec
UPDATE members
SET is_active = TRUE
WHERE membership_number = $1
`

func (q *Queries) ReactivateMember(ctx context.Context, membershipNumber int32) error {
	_, err := q.db.Exec(ctx, reactivateMember, membershipNumber)
	return err
}

const updateMemberEmail = `-- name: UpdateMemberEmail :exec
UPDATE members
SET email = $2, updated_at = CURRENT_TIMESTAMP
WHERE membership_number = $1
`

type UpdateMemberEmailParams struct {
	MembershipNumber int32
	Email            pgtype.Text
}

func (q *Queries) UpdateMemberEmail(ctx context.Context, arg UpdateMemberEmailParams) error {
	_, err := q.db.Exec(ctx, updateMemberEmail, arg.MembershipNumber, arg.Email)
	return err
}

const updateMemberPhone = `-- name: UpdateMemberPhone :exec
UPDATE members
SET phone = $2, updated_at = CURRENT_TIMESTAMP
WHERE membership_number = $1
`

type UpdateMemberPhoneParams struct {
	MembershipNumber int32
	Phone            pgtype.Text
}

func (q *Queries) UpdateMemberPhone(ctx context.Context, arg UpdateMemberPhoneParams) error {
	_, err := q.db.Exec(ctx, updateMemberPhone, arg.MembershipNumber, arg.Phone)
	return err
}

const updateMembershipType = `-- name: UpdateMembershipType :exec
UPDATE members
SET is_bowling_member = $2, is_life_member = $3, updated_at = CURRENT_TIMESTAMP
WHERE membership_number = $1
`

type UpdateMembershipTypeParams struct {
	MembershipNumber int32
	IsBowlingMember  pgtype.Bool
	IsLifeMember     pgtype.Bool
}

func (q *Queries) UpdateMembershipType(ctx context.Context, arg UpdateMembershipTypeParams) error {
	_, err := q.db.Exec(ctx, updateMembershipType, arg.MembershipNumber, arg.IsBowlingMember, arg.IsLifeMember)
	return err
}
